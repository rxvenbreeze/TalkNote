<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Audio Note Taker</title>
    <style>
        /* --- Modern Minimalist Styles --- */
        *, *::before, *::after { box-sizing: border-box; }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            background-color: #f4f6f8; /* Lighter, softer background */
            color: #333;
            line-height: 1.6;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .app-container {
            width: 100%;
            max-width: 850px; /* Slightly wider for better layout */
            margin: 20px auto;
            background-color: #ffffff;
            padding: 25px 30px; /* Adjusted padding */
            border-radius: 12px;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.07); /* Softer shadow */
        }

        h1 {
            text-align: center;
            color: #2c3e50; /* Dark slate blue */
            margin-top: 0;
            margin-bottom: 30px;
            font-size: 2.2em; /* Slightly larger h1 */
            font-weight: 600;
        }

        h2 {
            color: #34495e; /* Darker blue-gray */
            margin-top: 30px; /* Add space above h2 */
            margin-bottom: 15px;
            font-size: 1.6em; /* Slightly larger h2 */
            font-weight: 500;
            border-bottom: 2px solid #e9ecef; /* Lighter border */
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #fdfdfd; /* Very light, almost white */
            border-radius: 8px;
            border: 1px solid #e9ecef; /* Lighter border */
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500; /* Slightly less bold */
            color: #495057; /* Darker gray for labels */
        }

        input[type="password"],
        input[type="text"] {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ced4da; /* Standard bootstrap-like border */
            border-radius: 6px;
            font-size: 1rem;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            background-color: #fff; /* Ensure white background */
        }
        input[type="password"]:focus,
        input[type="text"]:focus {
            border-color: #80bdff; /* Lighter blue focus */
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.20);
            outline: none;
        }

        .button-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 12px; /* Increased gap */
            margin-top: 15px;
        }

        button {
            padding: 10px 18px; /* Adjusted padding */
            font-size: 0.95rem; /* Slightly smaller font for buttons */
            font-weight: 500;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.08);
        }
        button:active {
            transform: translateY(0px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        button:disabled {
            background-color: #e9ecef !important; /* Use important to override specific styles */
            color: #6c757d !important;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Specific button colors */
        #startButton { background-color: #28a745; } /* Green */
        #startButton:hover:not(:disabled) { background-color: #218838; }
        #stopButton { background-color: #dc3545; } /* Red */
        #stopButton:hover:not(:disabled) { background-color: #c82333; }
        
        #newSectionButton { background-color: #6f42c1; } /* Purple */
        #newSectionButton:hover:not(:disabled) { background-color: #5a32a3; }
        #organizeButton { background-color: #fd7e14; } /* Orange */
        #organizeButton:hover:not(:disabled) { background-color: #e6690b; }

        #clearButton, #clearApiKeyButton { background-color: #ffc107; color: #212529; } /* Yellow */
        #clearButton:hover:not(:disabled), #clearApiKeyButton:hover:not(:disabled) { background-color: #e0a800; }
        
        #downloadRawButton, #downloadOrganizedButton, #saveApiKeyButton { background-color: #007bff; } /* Primary Blue */
        #downloadRawButton:hover:not(:disabled), #downloadOrganizedButton:hover:not(:disabled), #saveApiKeyButton:hover:not(:disabled) { background-color: #0056b3; }

        textarea {
            width: 100%;
            min-height: 220px;
            padding: 12px 15px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 0.95rem;
            line-height: 1.5;
            resize: vertical;
            margin-bottom: 10px;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        textarea:focus {
            border-color: #80bdff;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.20);
            outline: none;
        }

        /* Status Messages */
        .status-message {
            text-align: center;
            margin: 15px 0;
            padding: 12px 15px;
            border-radius: 6px;
            font-size: 0.9em;
            border: 1px solid transparent;
        }
        #status { /* Speech status */
            background-color: #e7f3fe; 
            color: #0c5460;
            border-color: #b8daff;
        }
        #geminiStatus { /* Gemini status */
            background-color: #d4edda; /* Bootstrap success light green */
            color: #155724;
            border-color: #c3e6cb;
        }
        #geminiStatus.error { /* For Gemini errors */
            background-color: #f8d7da; /* Bootstrap danger light red */
            color: #721c24;
            border-color: #f5c6cb;
        }
        #apiKeyStatus {
            font-size: 0.85em;
            text-align: center;
            color: #6c757d; /* Muted gray */
            margin-top: 8px;
        }

        .notes-group {
            margin-bottom: 30px;
        }
    </style>
    <!-- SDK import will be handled by script type="module" -->
</head>
<body>
    <div class="app-container">
        <h1>AI Enhanced Audio Note Taker</h1>

        <div class="control-group">
            <h2>Configuration</h2>
            <label for="apiKey">Gemini API Key:</label>
            <input type="password" id="apiKey" placeholder="Enter your Gemini API Key">
            <p id="apiKeyStatus">API Key will be stored in your browser's local storage. Do not use on shared computers.</p>
            <div class="button-bar">
                <button id="saveApiKeyButton">Save Key</button>
                <button id="clearApiKeyButton">Clear Saved Key</button>
            </div>
        </div>

        <div class="control-group">
            <h2>Voice Recording</h2>
            <div class="button-bar">
                <button id="startButton">Start Recording</button>
                <button id="stopButton" disabled>Stop Recording</button>
                <button id="newSectionButton">New Section Marker</button>
            </div>
            <p id="status" class="status-message">Status: Idle. Enter API Key & Click "Start Recording".</p>
        </div>
        
        <div class="notes-group">
            <h2>Raw Transcribed Notes</h2>
            <textarea id="notesArea" placeholder="Your transcribed notes will appear here..."></textarea>
            <div class="button-bar">
                <button id="clearButton">Clear Raw Notes</button>
                <button id="downloadRawButton">Download Raw Notes</button>
            </div>
        </div>

        <div class="notes-group">
            <h2>Organized Notes (via Gemini)</h2>
            <div class="button-bar" style="margin-bottom: 15px;"> <!-- Added margin here for spacing -->
                 <button id="organizeButton" disabled>Organize with Gemini</button>
            </div>
            <p id="geminiStatus" class="status-message">Status: Waiting for raw notes to organize.</p>
            <textarea id="organizedNotesArea" placeholder="Organized notes will appear here after processing with Gemini..." readonly></textarea>
            <div class="button-bar">
                 <button id="downloadOrganizedButton">Download Organized Notes</button>
            </div>
        </div>
    </div>

    <script type="module">
        let GoogleGenerativeAI;
        try {
            // Dynamically import the GoogleGenerativeAI module
            const genAIModule = await import('https://esm.run/@google/generative-ai');
            GoogleGenerativeAI = genAIModule.GoogleGenerativeAI;
        } catch (e) {
            console.error("CRITICAL: Error loading GoogleGenerativeAI SDK:", e);
            const geminiStatusEl = document.getElementById('geminiStatus');
            geminiStatusEl.textContent = "Error loading Google AI SDK. Ensure you are online and try refreshing. Check browser console (F12) for more details.";
            geminiStatusEl.classList.add('error');
            // Disable Gemini-related functionality
            document.getElementById('organizeButton').disabled = true;
            document.getElementById('apiKey').disabled = true;
            document.getElementById('saveApiKeyButton').disabled = true;
        }

        // DOM Elements
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const newSectionButton = document.getElementById('newSectionButton');
        const clearButton = document.getElementById('clearButton');
        const downloadRawButton = document.getElementById('downloadRawButton');
        const notesArea = document.getElementById('notesArea');
        const statusDiv = document.getElementById('status');

        const apiKeyInput = document.getElementById('apiKey');
        const saveApiKeyButton = document.getElementById('saveApiKeyButton');
        const clearApiKeyButton = document.getElementById('clearApiKeyButton');
        const apiKeyStatus = document.getElementById('apiKeyStatus');
        const organizeButton = document.getElementById('organizeButton');
        const geminiStatus = document.getElementById('geminiStatus');
        const organizedNotesArea = document.getElementById('organizedNotesArea');
        const downloadOrganizedButton = document.getElementById('downloadOrganizedButton');

        let SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        let isRecording = false;
        let genAIInstance;

        // --- API Key Management ---
        function loadApiKey() {
            const savedKey = localStorage.getItem('geminiApiKey');
            if (savedKey) {
                apiKeyInput.value = savedKey;
                apiKeyStatus.textContent = "API Key loaded from local storage.";
                if (GoogleGenerativeAI) initializeGemini();
            } else {
                apiKeyStatus.textContent = "Enter API Key to enable AI features. It will be stored in your browser's local storage.";
            }
        }

        saveApiKeyButton.addEventListener('click', () => {
            const key = apiKeyInput.value.trim();
            if (key) {
                localStorage.setItem('geminiApiKey', key);
                apiKeyStatus.textContent = "API Key saved to local storage.";
                if (GoogleGenerativeAI) initializeGemini();
                else geminiStatus.textContent = "API Key saved, but AI SDK failed to load. Please refresh or check console.";
            } else {
                alert("Please enter an API Key.");
            }
        });

        clearApiKeyButton.addEventListener('click', () => {
            localStorage.removeItem('geminiApiKey');
            apiKeyInput.value = '';
            apiKeyStatus.textContent = "Saved API Key cleared. Enter new key.";
            genAIInstance = null;
            organizeButton.disabled = true;
            geminiStatus.textContent = "API Key cleared. Gemini features disabled until a new key is provided.";
            geminiStatus.classList.remove('error');
        });
        
        function initializeGemini() {
            if (!GoogleGenerativeAI) {
                geminiStatus.textContent = "Gemini SDK not loaded. Cannot initialize AI features.";
                geminiStatus.classList.add('error');
                organizeButton.disabled = true;
                return;
            }
            const apiKey = apiKeyInput.value.trim();
            if (apiKey) {
                try {
                    genAIInstance = new GoogleGenerativeAI(apiKey);
                    geminiStatus.textContent = "Gemini initialized. Ready to organize notes.";
                    geminiStatus.classList.remove('error');
                    organizeButton.disabled = notesArea.value.trim().length === 0;
                } catch (error) {
                    console.error("Error initializing Gemini:", error);
                    geminiStatus.textContent = `Error initializing Gemini: ${error.message}. Check API Key & console.`;
                    geminiStatus.classList.add('error');
                    organizeButton.disabled = true;
                }
            } else {
                geminiStatus.textContent = "API Key is missing. Please enter your Gemini API Key.";
                geminiStatus.classList.remove('error'); // Not an error state, just informational
                organizeButton.disabled = true;
            }
        }

        // --- Speech Recognition Logic ---
        if (!SpeechRecognition) {
            statusDiv.textContent = "Speech Recognition not supported. Try Chrome or Edge.";
            statusDiv.style.backgroundColor = "#f8d7da"; // Error color
            statusDiv.style.color = "#721c24";
            startButton.disabled = true;
            stopButton.disabled = true;
            newSectionButton.disabled = true;
        } else {
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = false; // Let's try false for cleaner final appends
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                isRecording = true;
                statusDiv.textContent = 'Status: Recording... Speak now!';
                startButton.disabled = true;
                stopButton.disabled = false;
                newSectionButton.disabled = false; // Enable when recording
            };

            recognition.onresult = (event) => {
                let finalTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript + ' '; // Add space between final segments
                    }
                }
                if (finalTranscript.trim()) {
                    const timestamp = new Date().toLocaleTimeString();
                    if (notesArea.value.length > 0 && !notesArea.value.endsWith('\n') && !notesArea.value.endsWith(' ')) {
                        notesArea.value += '\n'; // Add newline if previous content doesn't end with one
                    }
                    // Append with timestamp, or decide if you want a more continuous flow
                    // For now, keeping timestamp per final utterance.
                    notesArea.value += `[${timestamp}] ${finalTranscript.trim()}\n`;
                    notesArea.scrollTop = notesArea.scrollHeight;
                    if (genAIInstance) organizeButton.disabled = false;
                }
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event);
                let errorMsg = 'Error during recognition: ' + event.error;
                if (event.error === 'no-speech') errorMsg = 'No speech detected. Microphone might not be picking up audio.';
                if (event.error === 'audio-capture') errorMsg = 'Audio capture error. Check microphone connection/permissions.';
                if (event.error === 'not-allowed') errorMsg = 'Microphone access denied by user or browser setting.';
                statusDiv.textContent = errorMsg;
                statusDiv.style.backgroundColor = "#f8d7da";
                statusDiv.style.color = "#721c24";
                // Call stopRecording to reset UI state consistently
                stopRecording();
            };

            recognition.onend = () => {
                // This event fires when recognition stops, either by stopButton, naturally, or due to an error.
                if (isRecording) { // If isRecording is true, it means .stop() wasn't called by our stopButton handler
                    statusDiv.textContent = 'Status: Recording session ended or timed out. Click "Start Recording" to begin a new session.';
                    isRecording = false; // Ensure state is updated
                    startButton.disabled = false;
                    stopButton.disabled = true;
                    newSectionButton.disabled = true; // Back to disabled if not recording
                     // Enable organize button only if there's text and AI is initialized
                    if (genAIInstance) organizeButton.disabled = notesArea.value.trim().length === 0;
                }
                // If isRecording is false, it means stopRecording() was already called (e.g., by user click or error handler)
                // and UI should be in the correct state.
            };
        }

        function startRecording() {
            if (!apiKeyInput.value.trim() && GoogleGenerativeAI) { // Check only if SDK loaded
                alert("Please enter and save your Gemini API Key to use all features, though recording will work.");
                // apiKeyInput.focus(); // User might want to record without AI key yet
            }
             if (recognition && !isRecording) {
                try {
                    // Optionally add a session start marker
                    // notesArea.value += `\n--- RECORDING SESSION STARTED AT ${new Date().toLocaleString()} ---\n`;
                    recognition.start();
                } catch (e) {
                    console.error("Error starting recognition:", e);
                    statusDiv.textContent = "Error starting recognition: " + e.message;
                    startButton.disabled = false;
                    stopButton.disabled = true;
                    newSectionButton.disabled = true;
                }
            }
        }

        function stopRecording() {
            if (recognition && isRecording) {
                recognition.stop(); // This will trigger onend
            }
            // The onend handler will now primarily handle the UI state update
            // if the stop was not user-initiated. If it was user-initiated (isRecording becomes false here),
            // then the onend handler's 'if (isRecording)' block won't execute.
            isRecording = false; // Crucial to set this *before* onend might fire due to recognition.stop()
            statusDiv.textContent = 'Status: Idle. Click "Start Recording" to begin.';
            statusDiv.style.backgroundColor = "#e7f3fe"; // Reset status color
            statusDiv.style.color = "#0c5460";
            startButton.disabled = false;
            stopButton.disabled = true;
            newSectionButton.disabled = true; // Disable when not recording
            if (genAIInstance) organizeButton.disabled = notesArea.value.trim().length === 0;
        }

        startButton.addEventListener('click', startRecording);
        stopButton.addEventListener('click', stopRecording);

        newSectionButton.addEventListener('click', () => {
            if (notesArea.value.length > 0 && !notesArea.value.endsWith('\n\n')) {
                if (!notesArea.value.endsWith('\n')) notesArea.value += '\n';
            }
            const timestamp = new Date().toLocaleTimeString();
            notesArea.value += `\n--- NEW SECTION MARKER (${timestamp}) ---\n\n`;
            notesArea.scrollTop = notesArea.scrollHeight;
        });

        clearButton.addEventListener('click', () => {
            if (confirm("Are you sure you want to clear raw notes?")) {
                notesArea.value = '';
                statusDiv.textContent = 'Status: Raw notes cleared.';
                if (genAIInstance) organizeButton.disabled = true;
            }
        });

        function downloadText(filenamePrefix, text) {
            if (!text.trim()) {
                alert("Nothing to download!");
                return false;
            }
            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            const now = new Date();
            const filenameDate = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
            const filenameTime = `${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}`;
            a.download = `${filenamePrefix}_${filenameDate}_${filenameTime}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
            return true;
        }

        downloadRawButton.addEventListener('click', () => {
            if(downloadText('raw_notes', notesArea.value)){
                // statusDiv.textContent = 'Status: Raw notes downloaded.'; // Avoid overwriting main status
            }
        });
        downloadOrganizedButton.addEventListener('click', () => {
            if(downloadText('organized_notes', organizedNotesArea.value)){
                 // geminiStatus.textContent = 'Status: Organized notes downloaded.'; // Avoid overwriting main status
            }
        });

        // --- Gemini Organization Logic ---
        organizeButton.addEventListener('click', async () => {
            if (!genAIInstance) {
                alert("Gemini is not initialized. Please check your API Key and ensure the AI SDK loaded correctly (check console for errors if persists).");
                if (GoogleGenerativeAI) initializeGemini(); // Try to init again if SDK is loaded
                return;
            }
            const rawNotes = notesArea.value.trim();
            if (!rawNotes) {
                alert("No raw notes to organize.");
                return;
            }

            geminiStatus.textContent = "Organizing notes with Gemini... Please wait.";
            geminiStatus.classList.remove('error');
            organizedNotesArea.value = "Processing with AI...";
            organizeButton.disabled = true;

            try {
                const model = genAIInstance.getGenerativeModel({ model: "gemini-1.5-flash-latest" });

                const prompt = `
You are an expert note-taking assistant. Please take the following raw, timestamped transcript from a lecture or meeting and organize it into clear, structured notes.

Your goal is to make the information easy to read, understand, and review.

Follow these instructions:
1.  **Identify Main Topics/Sections:** Group related information under clear headings. Use Markdown style for headings (e.g., ## Topic Title). If there are "NEW SECTION MARKER" entries, use them as cues for topic changes, but also infer topics from content.
2.  **Key Points & Summaries:** For each topic, extract the most important points, definitions, examples, decisions, or action items. Use bullet points (* or -) or numbered lists for clarity.
3.  **Conciseness & Clarity:** Rephrase for clarity and conciseness. Remove conversational filler (e.g., "um," "uh," "like," "you know") and redundancies, but retain essential meaning and context.
4.  **Structure:** Present the notes in a logical flow. Create an overall summary at the beginning if appropriate for the content length and complexity.
5.  **Timestamps:** Generally, do not include the original timestamps in the organized output unless a specific time reference is critical to understanding a point (e.g., "The decision was made at [timestamp] to...").
6.  **Formatting:** Use simple Markdown for formatting (headings, **bold** for emphasis, *italics* for nuance, bullet points, numbered lists). Do not use complex HTML.
7.  **Action Items:** If any action items are mentioned, list them clearly, perhaps in a dedicated "Action Items" section at the end or under relevant topics.

Here is the raw transcript:
--- START OF TRANSCRIPT ---
${rawNotes}
--- END OF TRANSCRIPT ---

Please provide the organized notes below:
`;

                const result = await model.generateContent(prompt);
                const response = await result.response;
                const text = response.text();
                
                organizedNotesArea.value = text;
                geminiStatus.textContent = "Notes organized successfully!";

            } catch (error) {
                console.error("Error calling Gemini API:", error);
                organizedNotesArea.value = `Error: Could not organize notes.\n${error.message}\n\nCheck browser console (F12) for more details. Common issues: Invalid API Key, quota exceeded, network problem, or AI model issue.`;
                geminiStatus.textContent = "Error organizing notes. See details in text area and console.";
                geminiStatus.classList.add('error');
            } finally {
                 if (genAIInstance) organizeButton.disabled = notesArea.value.trim().length === 0;
            }
        });

        // --- Initial Load ---
        if (GoogleGenerativeAI) { // Only try to load API key if SDK itself loaded
            loadApiKey();
        } else {
            apiKeyStatus.textContent = "AI features disabled as AI SDK failed to load.";
            organizeButton.disabled = true;
        }
        // Initial check for organize button state based on conditions
        if (genAIInstance) {
            organizeButton.disabled = notesArea.value.trim().length === 0;
        } else {
            organizeButton.disabled = true;
        }
         // Initialize button states based on whether recording is active or not
        newSectionButton.disabled = !isRecording;


    </script>
</body>
</html>
